<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Resumo | Engenharia Reversa e Assembly - PF Perito Digital</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f7fb;
      color: #1f2937;
      line-height: 1.6;
      padding: 30px;
    }
    h1, h2, h3 {
      color: #1e3a8a;
    }
    h1 {
      border-bottom: 3px solid #2563eb;
      padding-bottom: 5px;
    }
    h2 {
      margin-top: 40px;
      border-left: 5px solid #3b82f6;
      padding-left: 10px;
    }
    h3 {
      color: #2563eb;
    }
    .box {
      background-color: #e0f2fe;
      border-left: 5px solid #0284c7;
      padding: 15px;
      margin: 20px 0;
    }
    .alerta {
      background-color: #fef9c3;
      border-left: 5px solid #facc15;
      padding: 15px;
      margin: 20px 0;
    }
    code {
      background-color: #e2e8f0;
      padding: 2px 5px;
      border-radius: 3px;
      font-family: monospace;
    }
  </style>
</head>
<body>

<h1>Engenharia Reversa + Linguagem Assembly</h1>

<h2>Engenharia Reversa de Software</h2>

<p>Ã‰ a prÃ¡tica de analisar um software para entender sua lÃ³gica, sem ter o cÃ³digo-fonte original. Essencial para perÃ­cia, malware analysis e recuperaÃ§Ã£o de software legados.</p>

<h3>ğŸ¯ PropÃ³sitos da Engenharia Reversa</h3>
<ul>
  <li>AnÃ¡lise de vulnerabilidades</li>
  <li>RecuperaÃ§Ã£o de algoritmos</li>
  <li>ValidaÃ§Ã£o de seguranÃ§a</li>
  <li>DetecÃ§Ã£o de malwares</li>
</ul>

<h3>ğŸ§° Ferramentas mais cobradas:</h3>
<ul>
  <li><strong>IDA Pro</strong> â€” desmontador e depurador estÃ¡tico</li>
  <li><strong>Ghidra</strong> â€” ferramenta da NSA, anÃ¡lise estÃ¡tica e reversa</li>
  <li><strong>OllyDbg</strong> â€” depuraÃ§Ã£o em ambiente Windows 32-bit</li>
  <li><strong>Radare2</strong> â€” suÃ­te CLI para engenharia reversa</li>
</ul>

<div class="alerta">
  <strong>ğŸ” CEBRASPE AMA:</strong> DiferenÃ§a entre <code>desmontagem</code> (assembly) e <code>descompilaÃ§Ã£o</code> (pseudocÃ³digo), ferramentas e tÃ©cnicas de proteÃ§Ã£o anti-reversing.
</div>

<h3>ğŸ§  Conceitos Importantes:</h3>
<ul>
  <li><strong>Desmontagem:</strong> de binÃ¡rio para Assembly</li>
  <li><strong>DescompilaÃ§Ã£o:</strong> de binÃ¡rio para pseudocÃ³digo</li>
  <li><strong>Debugging:</strong> execuÃ§Ã£o passo a passo para anÃ¡lise</li>
  <li><strong>Empacotamento:</strong> compactar e proteger executÃ¡veis</li>
  <li><strong>Anti-debugging:</strong> tÃ©cnicas que impedem depuradores</li>
</ul>

<h3>âš™ï¸ TÃ©cnicas Comuns</h3>
<ul>
  <li>Breakpoint & stepping</li>
  <li>AnÃ¡lise de strings e imports</li>
  <li>Monitoramento de chamadas de API</li>
</ul>

<div class="box">
  <strong>Dica de Ouro:</strong> Veja como o cÃ³digo se transforma: <code>Fonte &rarr; Compilador &rarr; BinÃ¡rio &rarr; Engenharia Reversa</code>.
</div>

<hr>

<h2>Linguagem Assembly</h2>

<p>A linguagem Assembly Ã© de baixo nÃ­vel, diretamente ligada ao processador. Toda engenharia reversa toca em Assembly â€” vocÃª PRECISA reconhecer padrÃµes.</p>

<h3>ğŸ§  Conceitos-chave</h3>
<ul>
  <li><strong>Registradores:</strong> EAX, EBX, ECX, EDX, EIP, ESP, EBP</li>
  <li><strong>Flags:</strong> ZF (Zero), CF (Carry), OF (Overflow)</li>
  <li><strong>SegmentaÃ§Ã£o:</strong> CÃ³digo, Dados, Stack</li>
</ul>

<h3>ğŸ” InstruÃ§Ãµes mais frequentes</h3>
<ul>
  <li><code>mov</code> â€” move dados entre registradores</li>
  <li><code>push/pop</code> â€” manipula pilha</li>
  <li><code>call/ret</code> â€” controle de fluxo (funÃ§Ãµes)</li>
  <li><code>jmp</code> â€” salto incondicional</li>
  <li><code>cmp</code> e <code>jz, jne, jl, jg</code> â€” comparaÃ§Ã£o e saltos condicionais</li>
  <li><code>int</code> â€” chamadas de interrupÃ§Ã£o (ex: <code>int 0x80</code> no Linux)</li>
</ul>

<h3>ğŸ¯ PadrÃµes que aparecem MUITO em questÃµes</h3>
<ul>
  <li><strong>FunÃ§Ãµes:</strong> sempre com <code>push</code> â†’ <code>call</code> â†’ <code>ret</code></li>
  <li><strong>Strings:</strong> operaÃ§Ãµes com <code>movsb</code>, <code>stosb</code>, <code>rep</code></li>
  <li><strong>Buffer overflow:</strong> manipulaÃ§Ã£o incorreta da pilha (<code>ESP</code>)</li>
</ul>

<div class="alerta">
  <strong>âš ï¸ CEBRASPE gosta:</strong> interpretaÃ§Ã£o de trechos curtos de Assembly, anÃ¡lise de lÃ³gica com <code>cmp</code> e <code>jmp</code>, e manipulaÃ§Ã£o de registradores.
</div>

<h3>ğŸ“Œ Exemplo de CÃ³digo Assembly (x86)</h3>
<pre><code>mov eax, 1
mov ebx, 0
int 0x80   ; chamada de sistema para exit(0)</code></pre>

<h3>ğŸ’¡ TrÃªs pilares que vocÃª precisa saber para a prova:</h3>
<ul>
  <li>Como identificar funÃ§Ã£o (stack frame: <code>push ebp / mov ebp, esp</code>)</li>
  <li>Como funciona um <code>call</code> e o <code>ret</code></li>
  <li>SequÃªncia tÃ­pica de comparaÃ§Ã£o + salto (<code>cmp eax, ebx / je label</code>)</li>
</ul>

<hr>

<h2>Checklist de MemorizaÃ§Ã£o RÃ¡pida</h2>
<ul>
  <li>ğŸ§  Registradores e suas funÃ§Ãµes</li>
  <li>âš™ï¸ FunÃ§Ãµes e chamadas de sistema</li>
  <li>ğŸ“Š Flag ZF e instruÃ§Ãµes de desvio</li>
  <li>ğŸ”§ Ferramentas de engenharia reversa</li>
  <li>ğŸ” DiferenÃ§a entre descompilaÃ§Ã£o vs desmontagem</li>
</ul>

<div class="box">
  <strong>Ãšltima dica:</strong> Monte mapas mentais de instruÃ§Ãµes Assembly com casos prÃ¡ticos. Ajuda muito na hora de identificar padrÃµes em provas objetivas da CESPE!
</div>

</body>
</html>
